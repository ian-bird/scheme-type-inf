;; standard code walker
(define (walk form from to)
  (cond ((equal? form from) to)
        ((list? form)
         (map (lambda (e) (walk e from to)) form))
        (else
         form)))


;; take a lambda and convert it to one with logic variables
(define (variablize-args lambda-form)
  (let ((args (cadr lambda-form))
        (body (nth lambda-form 2)))
    (reduce (lambda (wip next-sub)
              (walk wip next-sub (string->symbol 
                                  (string-append "?" 
                                                 (symbol->string 
                                                  next-sub)))))
            body
            args)))

;; convert values with their types, except first element in list
;; since thats a function calls
(define (typify-constants code-statement)
  (let ((convert-element
	 (lambda (element)
	   (cond ((number? element) 'number)
         ((var? element) element)
		 ((symbol? element) 'symbol)
		 ((boolean? element) element)
		 ((procedure? element) 'fn)
		 ((list? element) (if (null? element)
                              'nil
                              (typify-constants element)))
		 (else panic)))))
    (if (list? code-statement)
        (if (null? code-statement)
            'nil
        (cons (car code-statement)
              (if (eq? (car code-statement) 'quote)
                  (list (convert-element
                         (cadr code-statement)))
                  (map convert-element (cdr code-statement)))))
        (convert-element code-statement))))

;; generates a new set of type facts where variables
;; line up properly
(define (type-facts)
  (let ((if-consq (new-var))
        (if-alt (new-var))
        (eqp (new-var))
        (qp (new-var))
	(equiv (new-var)))
    `((car pair ,(new-var))
      (cdr pair ,(new-var))
      (cons ,(new-var) ,(new-var) pair)
      (label symbol ,(new-var) nil)
      (if #f ,(new-var) ,if-alt ,if-alt)
      (if #t ,if-consq ,(new-var) ,if-consq)
      (eq? ,(new-var) ,(new-var) #f)
      (eq? ,eqp ,eqp #t)
      (atom? pair #f)
      (atom? nil #t)
      (atom? bool #t)
      (atom? symbol #t)
      (atom? number #t)
      (atom? fn #t)
      (lambda ,(new-var) ,(new-var))
      (quote ,qp ,qp)
      (funcall pair) ; these are placeholders for now
      (funcall nil)
      (funcall bool)
      (funcall symbol)
      (funcall number)
      (funcall fn)
      (funcall pair)
      (bool? bool)
      (bool? #t)
      (bool? #f)
      (logic-equiv ,equiv ,equiv))))

;; convert a lisp statement into a logical statement
(define (logic<- statement cont)
  (if (list? statement)
      (let* ((maybe-arg
	      (lambda (n)
		(if (> (count statement) n)
		    (nth statement n)
		    '())))
	     (arg1 (maybe-arg 1))
	     (arg2 (maybe-arg 2))
	     (arg3 (maybe-arg 3))
	     (arg1-cont (new-var))
	     (arg2-cont (new-var))
	     (arg3-cont (new-var)))
	(case (car statement)
	  ((if) (logic-and (logic<- arg1 arg1-cont)
			   (groups<- `(bool? ,arg1-cont))
			   (logic-or (logic-and (logic<- arg2 arg2-cont)
						(groups<-
						 `(if #t ,arg2-cont ,(new-var) ,cont)))
				     (logic-and (logic<- arg3 arg3-cont)
						(groups<-
						 `(if #f ,(new-var) ,arg3-cont ,cont))))))
	  ((eq?) (logic-and (logic<- arg1 arg1-cont)
			    (logic<- arg2 arg2-cont)
			    (groups<-
			     `(eq? ,arg1-cont ,arg2-cont ,cont))))
	  ((atom?) (logic-and (logic<- arg1 arg1-cont)
			      (groups<-
			       `(atom? ,arg1-cont ,cont))))
	  ((car)  (logic-and (logic<- arg1 arg1-cont)
			     (groups<-
			      `(car ,arg1-cont ,cont))))
	  ((cdr)  (logic-and (logic<- arg1 arg1-cont)
			     (groups<-
			      `(cdr ,arg1-cont ,cont))))
	  ((cons)  (logic-and (logic<- arg1 arg1-cont)
			      (logic<- arg2 arg2-cont)
			      (groups<-
			       `(cons ,arg1-cont ,arg2-cont ,cont))))
	  ((lambda) (logic-and (logic<- (variablize-args
					 (typify-constants
					  statement)) arg1-cont)
			       (groups<-
				`(lambda ,arg1-cont ,cont))))
	  ((label)  (logic-and (logic<- arg1 arg1-cont)
			       (logic<- arg2 arg2-cont)
			       (groups<-
				`(label ,arg1-cont ,arg2-cont ,cont))))
	  ((quote)  ; erm, what are we supposed to do here?
	   (groups<- `(quote ,(if (pair? arg1)
                              'pair
                              arg1)
                         ,cont)))
	  (else (groups<- `(funcall ,cont)))))
      (groups<- `(logic-equiv ,statement ,cont))))

;; remove variables from a results list that were generated by gensyms
(define (remove-gensym-vars result)
  (map (lambda (groups)
         (remove null? (map (lambda (group)
                              (remove gensym-var? group))
                            groups)))
       result))

(define (groups<- to-convert) (valid-groups (type-facts) to-convert))

;; removes repeated data and reformats output as a list of vars consed to
;; the valid types for those vars
(define (organize-output valid-groups)
  (map (lambda (var)
	 (cons var
	       (reject var?
		       (uniq
			(map (lambda (e) (if (bool? e)
					     'bool
					     e))
			     (apply append
				    (filter (lambda (group) (contains? group var))
					    (apply append valid-groups))))))))
       (uniq (filter var? (flatten valid-groups)))))
;; this is too complex. what are the actual steps?
;; get all the vars.
;; go through each group theyre in.
;; collect the types it could be in each one
;; groups with no concrete type are any types
;;
;; we still want some way to be able to mark that two variables are always related -- how?
;;     > perhaps by adding the variable in the type list for each arg???
;; this is important because it allows us to make deductions about output types sometimes.
;;
;; we only need to add the var type if the association is present in every group.
;; on the other hand, a type needs to be added even if it only appears in one group.



;; output = (((?result nil) (?a) (#t)) (?result) (nil ?a) (#f))
(define (type-check lambda-form) 
  (remove-gensym-vars
   (logic<- 
    (typify-constants
     (variablize-args
      lambda-form))
    '?result)))
