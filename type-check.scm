;; standard code walker
(define (walk form from to)
  (cond ((equal? form from) to)
        ((list? form)
         (map (lambda (e) (walk e from to)) form))
        (else
         form)))

(define (var<-symbol s)
  (string->symbol
   (string-append "?"
                  (symbol->string
                   s))))

;; take a lambda and convert it to one with logic variables
(define (variablize-args lambda-form)
  (let ((args (cadr lambda-form))
        (body (nth lambda-form 2)))
    (reduce (lambda (wip next-sub)
              (walk wip next-sub (var<-symbol next-sub)))
            body
            args)))

;; convert values with their types, except first element in list
;; since thats a function calls
(define (typify-constants code-statement)
  (let ((convert-element
	 (lambda (element)
	   (cond ((number? element) 'number)
         ((var? element) element)
		 ((symbol? element) 'symbol)
		 ((boolean? element) element)
		 ((procedure? element) 'fn)
		 ((list? element) (if (null? element)
                              'nil
                              (typify-constants element)))
		 (else panic)))))
    (if (list? code-statement)
        (if (null? code-statement)
            'nil
        (cons (car code-statement)
              (if (eq? (car code-statement) 'quote)
                  (list (convert-element
                         (cadr code-statement)))
                  (map convert-element (cdr code-statement)))))
        (convert-element code-statement))))

;; generates a new set of type facts where variables
;; line up properly
(define (type-facts)
  (let ((if-consq (new-var))
        (if-alt (new-var))
        (eqp (new-var))
        (qp (new-var))
	(equiv (new-var)))
    `((car pair ,(new-var))
      (cdr pair ,(new-var))
      (cons ,(new-var) ,(new-var) pair)
      (label symbol ,(new-var) nil)
      (if-f #f ,(new-var) ,if-alt ,if-alt)
      (if-t #t ,if-consq ,(new-var) ,if-consq)
      (eq? ,(new-var) ,(new-var) #f)
      (eq? ,eqp ,eqp #t)
      (atom? pair #f)
      (atom? #f #t)
      (atom? #t #t)
      (atom? nil #t)
      (atom? symbol #t)
      (atom? number #t)
      (atom? fn #t)
      (lambda ,(new-var) ,(new-var))
      (quote ,qp ,qp)
      (funcall pair) ; these are placeholders for now
      (funcall nil)
      (funcall #f)
      (funcall #t)
      (funcall symbol)
      (funcall number)
      (funcall fn)
      (funcall pair)
      (logic-equiv ,equiv ,equiv))))

;; convert a lisp statement into a logical statement
(define (logic<- statement cont)
  (if (list? statement)
      (let* ((maybe-arg
	      (lambda (n)
		(if (> (count statement) n)
		    (nth statement n)
		    '())))
	     (arg1 (maybe-arg 1))
	     (arg2 (maybe-arg 2))
	     (arg3 (maybe-arg 3))
	     (arg1-cont (new-var))
	     (arg2-cont (new-var))
	     (arg3-cont (new-var)))
	(case (car statement)
	  ((if) (logic-and (logic<- arg1 arg1-cont)
			   (logic-or (logic-and (logic<- arg2 arg2-cont)
						(groups<-
						 `(if-t ,arg1-cont ,arg2-cont ,(new-var) ,cont)))
				     (logic-and (logic<- arg3 arg3-cont)
						(groups<-
						 `(if-f ,arg1-cont ,(new-var) ,arg3-cont ,cont))))))
	  ((eq?) (logic-and (logic<- arg1 arg1-cont)
			    (logic<- arg2 arg2-cont)
			    (groups<-
			     `(eq? ,arg1-cont ,arg2-cont ,cont))))
	  ((atom?) (logic-and (logic<- arg1 arg1-cont)
			      (groups<-
			       `(atom? ,arg1-cont ,cont))))
	  ((car)  (logic-and (logic<- arg1 arg1-cont)
			     (groups<-
			      `(car ,arg1-cont ,cont))))
	  ((cdr)  (logic-and (logic<- arg1 arg1-cont)
			     (groups<-
			      `(cdr ,arg1-cont ,cont))))
	  ((cons)  (logic-and (logic<- arg1 arg1-cont)
			      (logic<- arg2 arg2-cont)
			      (groups<-
			       `(cons ,arg1-cont ,arg2-cont ,cont))))
	  ((lambda) (logic-and (logic<- (variablize-args
					 (typify-constants
					  statement)) arg1-cont)
			       (groups<-
				`(lambda ,arg1-cont ,cont))))
	  ((label)  (logic-and (logic<- arg1 arg1-cont)
			       (logic<- arg2 arg2-cont)
			       (groups<-
				`(label ,arg1-cont ,arg2-cont ,cont))))
	  ((quote)  ; erm, what are we supposed to do here?
	   (groups<- `(quote ,(if (pair? arg1)
                              'pair
                              arg1)
                         ,cont)))
	  (else (groups<- `(funcall ,cont)))))
      (groups<- `(logic-equiv ,statement ,cont))))

;; remove variables from a results list that were generated by gensyms
(define (remove-gensym-vars result)
(uniq
  (map (lambda (groups)
         (filter (lambda (group) (any? var? group))
         (remove null? (map (lambda (group)
                              (remove gensym-var? group))
                            groups))))
       result)))

(define (groups<- to-convert) (valid-groups (type-facts) to-convert))

(define (format-output original-form choices)
  (let* ((add-anys (lambda (group)
		     (if (every? var? group)
			 (cons 'any group)
			 group)))
	 (vars  (append (map var<-symbol (cadr  original-form))
			'(?result)))
	 (convert-choice
	  (lambda (choice)
	    (map (lambda (var)
		   (cons var
			 (uniq
			  (remove var?
				  (flatten
				   (filter (lambda (g)
					     (contains? g var))
					   (map add-anys choice)))))))
		 vars))))
    (map convert-choice choices)))

(define (type-check lambda-form)
  (format-output lambda-form
		 (remove-gensym-vars
		  (logic<- 
		   (typify-constants
		    (variablize-args
		     lambda-form))
		   '?result))))
